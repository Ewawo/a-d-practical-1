\documentclass[a4paper]{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[english]{babel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}[section]
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[svgnames]{xcolor}

\newcommand{\instruction}[1]{\textcolor{blue}{#1}}

\title{Vierdaagse feesten}								
\author{Eduardo van benthum \\ Tan Hoang}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother


\begin{document}

%%% Title %%%
\begin{center}
\rule{\linewidth}{0.2 mm} \\[0.4 cm]
{ \huge \bfseries \thetitle}\\
\rule{\linewidth}{0.2 mm} \\[0.5 cm]
\textsc{\Large Algorithms and Data Structures}\\[0.2 cm]				
\textsc{\large Practical 1}\\[0.5 cm]				

\begin{minipage}{0.4\textwidth}
    \begin{flushleft} \large
        \emph{Group 77}\\
        \theauthor
        \end{flushleft}
        \end{minipage}~
        \begin{minipage}{0.4\textwidth}
        \begin{flushright} \large
        ~\\
        s1173075\\	s1169891
    \end{flushright}
\end{minipage}\\[1 cm]
\end{center}


\section{Explanation of the Algorithm}
\subsection{Initialization}
The system reads input using Python's built-in \texttt{input()} function. The first two numbers are the number of vertices and edges. Each group of three numbers after that defines an edge: the two vertices it connects and its road type (0 = WALKING, 1 = BUS, 2 = BOTH). These edges are stored in a list as instances of the \texttt{Edge} class, each with fields \texttt{vertex1}, \texttt{vertex2}, and \texttt{road\_type}. 
After parsing, a \texttt{SetUnion} object is created with the number of vertices. Its \texttt{parent} array is initialized to \([0, 1, \dots, \text{number\_of\_vertices}-1]\), representing that each vertex is initially its own group.
At the end of initialization, the system has a list of all edges and a \texttt{SetUnion} instance.

\subsection{Algorithm Logic}
The goal of the algorithm is to find the minimum number of roads needed so that every stage is reachable either by bus or walking.
\\
\\
The Algorithm that our algorithm is based on is Kruskal minimum spanning tree. Which uses a union find data structure (just like our algorithm) to determine wheter adding an edge connects two different groups or creates an cycle. Both algorithms follow a greedy approach. The difference with our algorithm is instead of prioritizing the minimum total edge weight in a single network, we prioritize edges that can be used by both walking and the bus, because if such a road exists between 2 stages, this will always be the most optimal road, since it can be used for both pedestrians and busses.
\\
\\
The approach is to use a Union-Find data structure to connect groups of vertices together.
Edges that do not connect new groups (which means it has no effect on reachability) are ignored.
This allows us to efficiently build up the graph while avoiding unnecessary edges.
\\
\\
In other words in the beginning every vertex is its own group and thus is its own parent.
When we add an edge, we check whether both vertices have the same parents. If so, this edge creates a cycle and does not improve reachability.
If the two vertices have different parents, the edge connects two separate components and thus improves reachability. We connect them by making one vertex the parent of the other.
\\
\\
The algorithm works on three stages:
\\
\\
Both roads:
First we process the edges that can be used by both walking and bus.
These are always beneficial because they improve reachability for both networks while using only one road.
We add them to a shared union structure that will later be used for both the walking and bus networks.
Each time an edge is used, we increase a counter called used roads.
We then copy the current union to create two separate ones, one for walking and one for bus.
This is needed because both have diferent roads from this point forward.
\\
\\
Single roads:
Now we can choose between doing the walking graph first or the bus graph, in our algorithm we chose walking first.
If a walking edge connects new components in the walking union, we increase the counter.
We now do the exactly the same but for the bus union and the bus edges.

After these three steps, we know how many roads are actually used.
The output of the algorithm is total edges - used roads

However there might be a case where one of the two groups (bus or walking) are not fully connected.
To check this we check whether both unions have exactly one connected component(group).
If either network has more than one group, it means that the initial graph was not connected.
In that case the algorithm returns -1.


\subsection{Returning the Answer}
The algorithm terminates when it has looped 3 times over (a part of) the edge list, each time proceccesing a different type of edge:
\\
\\
1. processing all both edges on the shared union.
\\
2. processing all walking edges on the walking union.
\\
3. processing all bus edges on the bus union.
\\
\\
After this the algorithm is "done", if the bus and walking union both contain only 1 group, it will print "total number of edges" - "number of used roads". Otherwise it will return -1.
\subsection{Optimizations}
We made some optimizations.\\1. in the intialization explained in 1.1, we splitted the list of all edges to 3 lists of all edges with the same road type. This way, in the algorithm we never loop over any edge more than once, so in total every edge is now handled 1 time. Before this was 3 times (both, walking, bus).
\\2. first we had 2 SetUnions from the start of function \texttt{find\_most\_closed\_roads} (1 for walking and 1 for bus). Then in the first iteration, we would union find on both these SetUnions. Now we've made the optimization to run the first union find (all edges marked BOTH) on 1 singular SetUnion. Then it will create a deepcopy of this set so that both walking and bus can run union find on their own edges.

\section{Correctness Analysis}
Our algorithm follows a greedy approach just like Kruskal's algorithm. In Kruskal's edges are added in the order of the weight(lowest to highest), connecting groups without creating a cycle. Just as we said in the algorithm logic, in our algorithm we use the same principle but with a different prioritize rule, we prioritize both(bus and walking) edges since these improve reachability for both networks at the same time.
\\
\\
The union datastructure that we use guarentees that each succesful union decreases the number of components while components can never split only merge.
Therefore if the walking and union end with only one component, that means that each network is connected.
And because edges are only added when they merge two seperate components, the result will give us the minimum number of used edges. 
\\
\\
If every edge has been processed and in the union there is still more then one component, this means there is somewhere a gap in the network without any edges connecting it. 
In that case there is no edge that could make a fully reachable network, so returning -1 is correct.



\section{Complexity Analysis}
The algorithm consists of three main parts: reading input, initializing the union-find data structures, and performing union-find operations for each edge type. 

1. \textbf{Reading input:} Each of the E edges is read once and categorized into one of three lists. This takes $O(E)$ time. 

2. \textbf{Initializing SetUnion:} A SetUnion object is created for V vertices. The parent array is initialized with $V$ elements, which requires $O(V)$ time. A deep copie of SetUnion is made for the walking union, which also takes $O(V)$ time.

3. \textbf{Union-Find operations:} For each edge, a union operation is performed. Each union calls find twice. Each find can take $O(V)$ in the worst case. There are $E$ edges in total, so the worst-case complexity of union-find operations is $O(E \cdot V)$.  

\textbf{Overall complexity:}  
\[
O(E + V + V + E \cdot V) = O(E \cdot V)
\]
\section{Reflection}
We found a working solution relatively quickly. Early on, we realized that we needed to transform the given graph into a single tree. This could be done in two ways: either remove edges to eliminate all cycles and count the removed edges, or build up the graph while only adding edges that don’t create a cycle. After some online research, we recognized that the second approach closely resembles Kruskal’s algorithm. This insight allowed us to implement the solution quite easily.
\end{document}