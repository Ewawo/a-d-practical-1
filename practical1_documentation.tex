\documentclass[a4paper]{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[english]{babel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}[section]
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[svgnames]{xcolor}

\newcommand{\instruction}[1]{\textcolor{blue}{#1}}

\title{Vierdaagse feesten}								
\author{Eduardo van benthum \\ Tan Hoang}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother


\begin{document}

%%% Title %%%
\begin{center}
\rule{\linewidth}{0.2 mm} \\[0.4 cm]
{ \huge \bfseries \thetitle}\\
\rule{\linewidth}{0.2 mm} \\[0.5 cm]
\textsc{\Large Algorithms and Data Structures}\\[0.2 cm]				
\textsc{\large Practical 1}\\[0.5 cm]				

\begin{minipage}{0.4\textwidth}
    \begin{flushleft} \large
        \emph{Group 77}\\
        \theauthor
        \end{flushleft}
        \end{minipage}~
        \begin{minipage}{0.4\textwidth}
        \begin{flushright} \large
        ~\\
        s1173075\\	s1169891
    \end{flushright}
\end{minipage}\\[1 cm]
\end{center}

\noindent\instruction{This is a template for practical 1, all text in blue and the pseudocode example may be removed. The report may have at most 6 pages in the current format. The current sections and subsections must be present in the report, additional subsections may be added. Additionally, you may add examples, figures or pseudocode snippets (see Algorithm~\ref{pseudocode}).}


\section{Explanation of the Algorithm}
\subsection{Initialization}
The system reads input using Python's built-in \texttt{input()} function. The first two numbers are the number of vertices and edges. Each group of three numbers after that defines an edge: the two vertices it connects and its road type (0 = WALKING, 1 = BUS, 2 = BOTH). These edges are stored in a list as instances of the \texttt{Edge} class, each with fields \texttt{vertex1}, \texttt{vertex2}, and \texttt{road\_type}. 
After parsing, a \texttt{SetUnion} object is created with the number of vertices. Its \texttt{parent} array is initialized to \([0, 1, \dots, \text{number\_of\_vertices}-1]\), representing that each vertex is initially its own group.
At the end of initialization, the system has a list of all edges and a \texttt{SetUnion} instance.

\subsection{Algorithm Logic}
The output of the algorithm is to find the minimum number of roads needed so that every stage is reachable either by bus or walking.
\\
\\
The Algorithm that our algorithm is based on is Kruskal minimum spanning tree. Which uses a union find data structure(just like our algorithm) to determine wheter adding a edge connects two different groups or creates an cycle. The difference with our algorithm is instead of prioritizing the minimum total edge weight in a single network, we prioritize edges that can be used by both walking and the bus, because these improve reachability for both networks at the same time.
\\
\\
The approach is to use a Union-Find data structure to connect groups of vertices together.
Edges that do not connect new groups (which means it has no effect on reachability) are ignored.
This allows us to efficiently build up the graph while avoiding unnecessary edges.
\\
\\
In other words in the beginning every vertex is its own group.
When we add an edge, we check whether it connects two different groups.
If the two vertices have different parents, the edge connects new components and is therefore useful. We connect them by making one vertex the parent of the other.
If they already share the same parent, the edge forms a cycle and does not help to connect the graph.
\\
\\
The algorithm works on three stages:
\\
\\
Both roads:
First we process the edges that can be used by both walking and bus.
These are always beneficial because they improve reachability for both networks while using only one road.
We add them to a shared union structure that will later be used for both the walking and bus networks.
Each time an edge is used, we increase a counter called used roads.
We then copy the current union to create two separate ones, one for walking and one for bus.
This is needed because both have diferent roads from this point forward.
\\
\\
Single roads:
Now we can choose between doing the walking graph first or the bus graph, in our algorithm we chose walking first.
If a walking edge connects new components in the walking union, we increase the counter.
We now do the exactly the same but for the bus union and the bus edges.

After these three steps, we know how many roads are actually used.
The output of the algorithm is total edges - used roads

However there might be a case where one of the two groups (bus or walking) is not fully connected.
To check this we check whether both unions have exactly one connected component(group).
If either network has more than one group, it means that there is a missing edge and the network is disconnected.
In that case the algorithm returns -1.


\subsection{Returning the Answer}
The algorithm terminates when it has looped 3 times over the edge list and each time proceccesing different type of edge:
\\
\\
1. processing all both edges on the shared union.
\\
2. processing all walking edges on the walking union.
\\
3. processing all bus edges on the bus union.
\\
\\
After this the algorithm is "done" it will print the total edges - used roads if the bus and walking union both contain of 1 group. Otherwise it will return -1. 
\subsection{Optimizations}
\instruction{Did you use any special tricks to make the algorithm faster in special cases based on the problem statement?}

\section{Correctness Analysis}
\instruction{Why is your algorithm correct? Provide precise arguments, supported by formal reasoning whenever needed. Think of an expanation to a critical colleague why your algorithm is correct. For examples, take a look at correctness proofs in the textbook (Algorithms Illuminated) or solutions to the weekly exercises.}


\section{Complexity Analysis}
\instruction{What is the big O complexity of your algorithm (including reading in the data and making the data structure)? The analysis should be written in terms of the given input parameters. For example, if the input includes sets $V$ of vertices and $E$ of edges the complexity analysis should result in a big-Oh complexity using $V$ and $E$. Include an explanation of your answer.} 


\section{Reflection}
\instruction{Briefly reflect on the project. For example, you can write about how easy it was to find a suitable algorithm? Or if your algorithm is not always correct on DOMjudge, why do you think you get wrong answers? Or if there are of additional ways to speed up the algorithm?}

\end{document}