\documentclass[a4paper]{article}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[english]{babel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}[section]
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[svgnames]{xcolor}

\newcommand{\instruction}[1]{\textcolor{blue}{#1}}

\title{Vierdaagse feesten}								
\author{Eduardo van benthum \\ Tan Hoang}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother


\begin{document}

%%% Title %%%
\begin{center}
\rule{\linewidth}{0.2 mm} \\[0.4 cm]
{ \huge \bfseries \thetitle}\\
\rule{\linewidth}{0.2 mm} \\[0.5 cm]
\textsc{\Large Algorithms and Data Structures}\\[0.2 cm]				
\textsc{\large Practical 1}\\[0.5 cm]				

\begin{minipage}{0.4\textwidth}
    \begin{flushleft} \large
        \emph{Group 77}\\
        \theauthor
        \end{flushleft}
        \end{minipage}~
        \begin{minipage}{0.4\textwidth}
        \begin{flushright} \large
        ~\\
        s1173075\\	s1169891
    \end{flushright}
\end{minipage}\\[1 cm]
\end{center}

\noindent\instruction{This is a template for practical 1, all text in blue and the pseudocode example may be removed. The report may have at most 6 pages in the current format. The current sections and subsections must be present in the report, additional subsections may be added. Additionally, you may add examples, figures or pseudocode snippets (see Algorithm~\ref{pseudocode}).}


\section{Explanation of the Algorithm}
\subsection{Initialization}
The system reads input using Python's built-in \texttt{input()} function. The first two numbers are the number of vertices and edges. Each group of three numbers after that defines an edge: the two vertices it connects and its road type (0 = WALKING, 1 = BUS, 2 = BOTH). These edges are stored in a list as instances of the \texttt{Edge} class, each with fields \texttt{vertex1}, \texttt{vertex2}, and \texttt{road\_type}. 
After parsing, a \texttt{SetUnion} object is created with the number of vertices. Its \texttt{parent} array is initialized to \([0, 1, \dots, \text{number\_of\_vertices}-1]\), representing that each vertex is initially its own group.
At the end of initialization, the system has a list of all edges and a \texttt{SetUnion} instance.

\subsection{Algorithm Logic}
\instruction{Explain what your approach is, and what the algorithm does. Explain which data structures did you use and why. In case you adapt existing algorithms, explain how and why you modified and incorporated it.}

\begin{algorithm}[h!]
    \caption{Pseudocode example.}
    \label{pseudocode}
    \begin{algorithmic}[1]
    \Function{Function}{arguments}
    \State Step 1
    \While{Condition 1 does not hold} F
    \If{Condition 2}
    \State \Return Yes
    \Else 
    \State Step 2
    \EndIf
    \EndWhile 
    \State \Return No
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

\subsection{Returning the Answer}
\instruction{When does the algorithm terminate and what is returned?}

\subsection{Optimizations}
We made some optimizations.\\1. in the intialization explained in 1.1, we splitted the list of all edges to 3 lists of all edges with the same road type. This way, in the algorithm we never loop over any edge more than once, so in total every edge is now handled 1 time. Before this was 3 times (both, walking, bus).
\\2. first we had 2 SetUnions from the start of function \texttt{find\_most\_closed\_roads} (1 for walking and 1 for bus). Then in the first iteration, we would union find on both these SetUnions. Now we've made the optimization to run the first union find (all edges marked BOTH) on 1 singular SetUnion. Then it will create a deepcopy of this set so that both walking and bus can run union find on their own edges.

\section{Correctness Analysis}
\instruction{Why is your algorithm correct? Provide precise arguments, supported by formal reasoning whenever needed. Think of an expanation to a critical colleague why your algorithm is correct. For examples, take a look at correctness proofs in the textbook (Algorithms Illuminated) or solutions to the weekly exercises.}


\section{Complexity Analysis}
The algorithm consists of three main parts: reading input, initializing the union-find data structures, and performing union-find operations for each edge type. 

1. \textbf{Reading input:} Each of the $E$ edges is read once and categorized into one of three lists. This takes $O(E)$ time. 

2. \textbf{Initializing SetUnion:} A SetUnion object is created for $V$ vertices. The \texttt{parent} array is initialized with $V$ elements, which requires $O(V)$ time. A deep copie of SetUnion is made for the walking union, which also takes $O(V)$ time.

3. \textbf{Union-Find operations:} For each edge, a union operation is performed. Each \texttt{union} calls \texttt{find} twice. Each \texttt{find} can take $O(V)$ in the worst case. There are $E$ edges in total, so the worst-case complexity of union-find operations is $O(E \cdot V)$.  

\textbf{Overall complexity:}  
\[
O(E + V + V + E \cdot V) = O(E \cdot V)
\]
\section{Reflection}
We found a working solution relatively quickly. Early on, we realized that we needed to transform the given graph into a single tree. This could be done in two ways: either remove edges to eliminate all cycles and count the removed edges, or build up the graph while only adding edges that don’t create a cycle. After some online research, we recognized that the second approach closely resembles Kruskal’s algorithm. This insight allowed us to implement the solution quite easily.
\end{document}